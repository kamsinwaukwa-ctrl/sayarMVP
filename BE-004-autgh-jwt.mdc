---
id: "BE-004"
title: "Auth & JWT"
owner: "@ai_agent"
status: "planned"
priority: "P0"
theme: "Platform Foundation"
user_story: "As a merchant, I want to securely authenticate and access my account so that I can manage my store safely."
labels: ["backend","auth","jwt","security","postgres","fastapi"]
dependencies: ["tasks/BE-001-db-schema-rls.md", "tasks/BE-003-openapi-contracts.md"]
created: "2025-01-27"
spec_refs:
  - "sayar_mvp_prd.md#merchant-onboarding"
  - "sayar_mvp_prd.md#tech-stack"
  - "sayar_mvp_prd.md#security"
touches:
  - "back/src/api/auth.py"
  - "back/src/services/auth_service.py"
  - "back/src/utils/jwt.py"
  - "back/src/dependencies/auth.py"
  - "back/src/middleware/rate_limit.py"
  - "back/tests/integration/test_auth.py"
  - "migrations/003_auth_tables.sql"
---

# INSTRUCTIONS — READ THIS FIRST WHEN CREATING NEW TASKS

This file is a single, self-contained **TASK** for an AI agent working on Sayar. **One task = one file.**
It is optimized for our stack (FastAPI + Supabase/Postgres + WhatsApp Cloud + Paystack/Korapay + APScheduler Outbox).

Keep scope tight. If a task feels big, split it into multiple task files and list them in `dependencies`.

---

## 1) High-Level Objective
Implement **self-managed** JWT authentication with owner/staff roles and **tenant isolation** by embedding `merchant_id` into JWTs and propagating the claims to Postgres so RLS policies apply automatically.

---

## 2) Background / Context (Optional but recommended)
We need secure, predictable auth that aligns with our **RLS policies** (which depend on `auth.jwt()->>'merchant_id'`). Managing JWT issuance in the API lets us keep the payload stable across BE/FE and reliably pass claims to Postgres on every request.

---

## 3) Assumptions & Constraints
- **ASSUMPTION:** **Self-managed auth in FastAPI** (users in Postgres `users` table), custom JWTs signed by our API.
- **CONSTRAINT:** JWT payload **must** include `merchant_id`, `sub` (user_id), `role`.
- **CONSTRAINT:** Supported roles: `owner`, `staff`.
- **CONSTRAINT:** Password hashing uses **Argon2id** (preferred) or **bcrypt >= 12**.
- **CONSTRAINT:** Every DB request sets `request.jwt.claims` so **RLS** sees the same claims.
- **CONSTRAINT:** All endpoints validate JWT and enforce tenant isolation.
- **CONSTRAINT:** Responses conform to **BE-003 OpenAPI v0.1**.

---

## 4) Scope
**In:** 
- Register/Login/Me/Refresh endpoints
- JWT issue/verify utilities
- Argon2id/bcrypt hashing + optional pepper
- Auth dependency that sets Postgres `request.jwt.claims`
- Minimal login rate-limiter (per-IP, per-account)
- OpenAPI docs + FE TypeScript types compliance

**Out:** 
- OAuth/SSO providers
- Password reset / email verification flows (future task)
- Staff invites (future task)

---

## 5) API Contract (if applicable)
**Base URL:** `/api/v1`

**Auth:** `Authorization: Bearer <JWT>` (except register/login/refresh)

### `POST /api/v1/auth/register`
Public. Creates merchant + owner user and returns access token.
```json
{
  "name": "John Doe",
  "email": "john@example.com",
  "password": "secure_password",
  "business_name": "My Store",
  "whatsapp_phone_e164": "+2348012345678"
}
```
**Response**
```json
{
  "ok": true,
  "data": {
    "token": "<access_jwt>",
    "user": {
      "id": "uuid",
      "name": "John Doe",
      "email": "john@example.com",
      "role": "owner",
      "merchant_id": "uuid"
    },
    "merchant": {
      "id": "uuid",
      "name": "My Store",
      "whatsapp_phone_e164": "+2348012345678"
    }
  }
}
```

### `POST /api/v1/auth/login`
Public. Returns access token and user.
```json
{ "email": "john@example.com", "password": "secure_password" }
```
**Response:** same shape as register (without `merchant` unless convenient).

### `GET /api/v1/auth/me`
Protected. Returns current user.
```json
{ "ok": true, "data": { "id":"uuid","name":"John","email":"john@example.com","role":"owner","merchant_id":"uuid" } }
```

### `POST /api/v1/auth/refresh`
Public (uses httpOnly refresh cookie). Returns new access token.
```json
{ "ok": true, "data": { "token": "<new_access_jwt>" } }
```

**Access JWT claims:**
```json
{ "sub":"<user_uuid>","email":"user@example.com","merchant_id":"<merchant_uuid>","role":"owner|staff","iat": 1700000000,"exp": 1700009000 }
```

---

## 6) Data Model & Migration (Postgres, UUIDs, kobo money)
**Tables touched:** `users`, `merchants` (add indexes if needed).  
**Migration file:** `migrations/003_auth_tables.sql`  
- Ensure `users(email)` unique index (already in BE-001).  
- Optional: `failed_login_attempts`, `last_login_at` (nullable), `password_changed_at`.

---

## 7) Types & Interfaces (if applicable)
```py
# back/src/models/auth.py
from pydantic import BaseModel, EmailStr
from typing import Optional
from uuid import UUID
from enum import Enum

class UserRole(str, Enum):
    OWNER = "owner"
    STAFF = "staff"

class RegisterRequest(BaseModel):
    name: str
    email: EmailStr
    password: str
    business_name: str
    whatsapp_phone_e164: str

class LoginRequest(BaseModel):
    email: EmailStr
    password: str

class UserResponse(BaseModel):
    id: UUID
    name: str
    email: EmailStr
    role: UserRole
    merchant_id: UUID

class AuthResponse(BaseModel):
    token: str
    user: UserResponse

class RegisterResponse(BaseModel):
    token: str
    user: UserResponse
    merchant: dict  # minimal merchant view

class JWTPayload(BaseModel):
    sub: str
    email: EmailStr
    merchant_id: str
    role: str
    iat: int
    exp: int
```
```ts
// front/src/types/api.ts (must match BE-003)
export interface AuthResponse { token: string; user: {
  id: string; name: string; email: string; role: 'owner'|'staff'; merchant_id: string;
}; }
```

---

## 8) Reliability & Outbox
- Short-lived access JWT (15–30m). Refresh via httpOnly cookie.
- Audit log events: `user_registered`, `user_login_success`, `user_login_failed`.

---

## 9) Observability (Logs & Metrics)
Emit structured logs:
- `user_registered`, `user_login_success`, `user_login_failed`
- `token_generated`, `token_refreshed`, `token_invalid`
- `auth_rls_claims_set` (on DB claim bridge)

Metrics:
- `auth_requests_total{route}`
- `auth_failures_total{reason}`
- `token_generations_total`
- `login_rate_limited_total`

---

## 10) Security Policies
- **Hashing:** **Argon2id (preferred)** or bcrypt(>=12) + server-side **pepper**.
- **JWT:** HS256 or ES256 with **kid** and rotation plan (note in ADR).
- **Rate limiting:** per-IP + per-account for `/login`.
- **Sanitization:** never log passwords/tokens; scrub PII in errors.
- **CORS:** allow FE origins only.
- **RLS bridging:** set `request.jwt.claims` per request before any tenant table access.

---

## 11) Security
- Validate JWT exp/nbf/iat and signature.
- Validate role in {owner, staff}. Enforce `merchant_id` presence.
- Deny on disabled user (future: `users.disabled_at`).

---

## 12) Environment / Secrets
- `JWT_SECRET_KEY`
- `JWT_ALGORITHM` (default `HS256`)
- `JWT_ACCESS_TOKEN_EXPIRE_MINUTES` (e.g., 20)
- `PASSWORD_PEPPER` (optional but recommended)
- `CORS_ORIGINS`

---

## 13) Context Plan
**Beginning (read-only in context):**
- `back/src/models/database.py`
- `sayar_mvp_prd.md`
- `openapi.json` (from BE-003)

**End state (must exist):**
- `back/src/utils/jwt.py`
- `back/src/services/auth_service.py`
- `back/src/dependencies/auth.py`
- `back/src/api/auth.py`
- `back/src/middleware/rate_limit.py`
- `migrations/003_auth_tables.sql`
- `back/tests/integration/test_auth.py`

---

## 14) Ordered Implementation Steps
1. **JWT Utilities** — `back/src/utils/jwt.py`
   - `create_access_token(payload: dict, expires_minutes: int) -> str`
   - `decode_jwt(token: str) -> dict` (validate signature/exp)

2. **Auth Service** — `back/src/services/auth_service.py`
   - `register(RegisterRequest) -> RegisterResponse`
   - `login(LoginRequest) -> AuthResponse`
   - Hash/verify password (Argon2id preferred; else bcrypt). Apply optional pepper.
   - Create merchant + owner on register (transaction).

3. **Auth Dependency + RLS Bridge** — `back/src/dependencies/auth.py`
   ```py
   @depends -> returns {user_id, merchant_id, role}
   # ALSO: set Postgres 'request.jwt.claims' = JWT payload (json) so RLS can enforce policies.
   ```

4. **Rate Limiter (login)** — `back/src/middleware/rate_limit.py`
   - Simple in-memory or Redis-based limiter per-IP and per-email.

5. **Auth API** — `back/src/api/auth.py`
   - `POST /auth/register`, `POST /auth/login`, `GET /auth/me`, `POST /auth/refresh`.
   - Set refresh token as httpOnly cookie in register/login if you opt-in now.

6. **Migration** — `migrations/003_auth_tables.sql`
   - (Optional) Add `failed_login_attempts`, `last_login_at`, supportive indexes.

7. **OpenAPI Compliance**
   - Ensure routes/types match BE-003. Regenerate TS client if needed.

8. **Tests** — `back/tests/integration/test_auth.py`
   - Register/Login happy paths
   - Bad password / nonexistent user
   - JWT verification
   - **RLS proof**: after auth, query a tenant table and confirm only that merchant’s rows are visible.

---

## 15) Acceptance Criteria
- Users can **register** (merchant+owner created) and **login**.
- Access JWT includes `merchant_id`, `sub`, `role` and is **validated** on protected routes.
- **RLS bridge** sets `request.jwt.claims`; queries only show tenant data.
- `/auth/me` returns the current user from JWT.
- (Optional) `/auth/refresh` returns a new access token (if refresh cookie implemented).
- Rate limiter throttles brute-force login attempts.
- OpenAPI and FE TS client compile without drift.

---

## 16) Testing Strategy (Integration-first)
```py
# back/tests/integration/test_auth.py (sketch)
import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_register_and_rls(app_client: AsyncClient):
    reg = await app_client.post("/api/v1/auth/register", json={
        "name": "A", "email": "a@example.com", "password": "P@ssw0rd!",
        "business_name": "Shop A", "whatsapp_phone_e164": "+2348000000001"
    })
    assert reg.status_code == 200
    token = reg.json()["data"]["token"]

    # hit a protected endpoint that reads a tenant table (e.g., /products)
    res = await app_client.get("/api/v1/products", headers={"Authorization": f"Bearer {token}"})
    assert res.status_code == 200
    # ensure only merchant rows are visible (seed data can assert merchant_id match)
```

---

## 17) Manual QA (copy-pasteable)
```bash
# Register
http POST :8000/api/v1/auth/register \
  name='John Doe' email='john@example.com' password='secure_password' \
  business_name='My Store' whatsapp_phone_e164='+2348012345678'

# Login
http POST :8000/api/v1/auth/login email='john@example.com' password='secure_password'

# Me
http GET :8000/api/v1/auth/me Authorization:"Bearer <token>"

# (Optional) Refresh
http POST :8000/api/v1/auth/refresh
```

---

## 18) Rollback Plan
- Remove auth routes and dependencies.
- Revert `migrations/003_auth_tables.sql` if schema additions were made.
- Temporarily disable rate limiter middleware if it impacts other routes.

---

## Notes / Links
- JWT: https://jwt.io/
- FastAPI Security: https://fastapi.tiangolo.com/advanced/security/
- Argon2id (argon2-cffi): https://pypi.org/project/argon2-cffi/
- Bcrypt: https://pypi.org/project/bcrypt/
- RLS claims pattern: `set_config('request.jwt.claims', <claims_json>, true)`
