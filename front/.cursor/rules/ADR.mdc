---
description: Architectural Decision Records
globs:
alwaysApply: false
---

# Architecture Decision Log

<!--
ADR_AGENT_PROTOCOL v1.0

You (the agent) manage this file as the single source of truth for all ADRs.

INVARIANTS
- Keep this exact file structure and headings.
- All ADR entries use H2 headings: "## ADR-XXXX — <Title>" (4-digit zero-padded ID).
- Allowed Status values: Proposed | Accepted | Superseded
- Date format: YYYY-MM-DD
- New entries must be appended to the END of the file.
- The Index table between the INDEX markers must always reflect the latest state and be sorted by ID desc (newest on top).
- Each ADR MUST contain: Date, Status, Owner, Context, Decision, Consequences.
- Each ADR must include an explicit anchor `<a id="adr-XXXX"></a>` so links remain stable.

HOW TO ADD A NEW ADR
1) Read the whole file.
2) Compute next ID:
   - Scan for headings matching: ^## ADR-(\d{4}) — .+$
   - next_id = (max captured number) + 1, left-pad to 4 digits.
3) Create a new ADR section using the “New ADR Entry Template” below.
   - Place it AFTER the last ADR section in the file.
   - Add an `<a id="adr-XXXX"></a>` line immediately below the heading.
4) Update the Index (between the INDEX markers):
   - Insert/replace the row for this ADR keeping the table sorted by ID descending.
   - Title in the Index MUST link to the anchor: [<Title>](#adr-XXXX)
   - If this ADR supersedes another: set “Supersedes” in this row, and update that older ADR:
       a) Change its Status to “Superseded”
       b) Add “Superseded by: ADR-XXXX” in its Consequences block
       c) Update the older ADR’s Index row “Superseded by” column to ADR-XXXX
5) Validate before saving:
   - Exactly one heading exists for ADR-XXXX
   - All required fields are present and non-empty
   - Index contains a row for ADR-XXXX and remains properly sorted
6) Concurrency resolution:
   - If a merge conflict or duplicate ID is detected after reading: recompute next_id from the current file state, rename your heading, anchor, and Index row accordingly, and retry once.

COMMIT MESSAGE SUGGESTION
- "ADR-XXXX: <Short Title> — <Status>"

END ADR_AGENT_PROTOCOL
-->

## Index

<!-- BEGIN:ADR_INDEX -->

| ID  | Title                                        | Date       | Status   |
| --- | -------------------------------------------- | ---------- | -------- |
| 0008 | [WhatsApp Commerce Frontend Architecture](#adr-0008) | 2025-01-27 | Accepted |
| 0007 | [State Management with React Query](#adr-0007) | 2025-01-27 | Accepted |
| 0006 | [Authentication with Supabase Auth](#adr-0006) | 2025-01-27 | Accepted |
| 0005 | [Styling with Tailwind CSS](#adr-0005)       | 2025-01-27 | Accepted |
| 0004 | [Build Tool with Vite](#adr-0004)            | 2025-01-27 | Accepted |
| 0003 | [TypeScript Configuration](#adr-0003)        | 2025-01-27 | Accepted |
| 0002 | [Project Structure for React SPA](#adr-0002) | 2025-01-27 | Accepted |
| 0001 | [Testing Strategy with Jest and RTL](#adr-0001) | 2025-01-27 | Accepted |

<!-- END:ADR_INDEX -->

## ADR-0001 — Testing Strategy with Jest and RTL

<a id="adr-0001"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar frontend requires a comprehensive testing strategy that validates React components, user interactions, and API integrations. Tests need to work with the Vite build system and provide good developer experience.

### Alternatives

- **Cypress for E2E only**: Comprehensive but slow for unit testing
- **Jest with jsdom**: Fast but limited browser testing
- **Jest + React Testing Library**: Fast unit tests with realistic user interactions

### Decision

Implement Jest + React Testing Library testing strategy:

- Use Jest as the test runner with Vite integration
- React Testing Library for component testing with user-centric approach
- Mock API calls and external dependencies
- Test user interactions and accessibility
- Coverage reporting for code quality

### Consequences

- **Pros**: Fast test execution, realistic user testing, excellent developer experience, good coverage reporting
- **Cons / risks**: Learning curve for testing patterns, requires understanding of mocking strategies
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

All components have unit tests. User interactions are tested with RTL. API calls are properly mocked. Test coverage meets minimum thresholds.

---

## ADR-0002 — Project Structure for React SPA

<a id="adr-0002"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar frontend needs a clear, maintainable structure that supports merchant dashboards, admin interfaces, and scales with the application growth.

### Alternatives

- **Feature-based structure**: Group by business features but harder to find shared components
- **Layer-based structure**: Group by technical concerns but harder to understand business logic
- **Hybrid structure**: Clear separation with both technical and business organization

### Decision

Implement hybrid project structure:

- `/src/components/` - Reusable UI components organized by type
- `/src/pages/` - Page components for different routes
- `/src/hooks/` - Custom React hooks for business logic
- `/src/lib/` - External service integrations (Supabase, API clients)
- `/src/types/` - TypeScript type definitions
- `/src/utils/` - Utility functions and helpers

### Consequences

- **Pros**: Clear organization, easy to find components, scalable structure, good separation of concerns
- **Cons / risks**: Some components might fit multiple categories, requires discipline to maintain structure
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Components are properly organized in their respective directories. Imports follow the established structure. New files are placed in appropriate locations.

---

## ADR-0003 — TypeScript Configuration

<a id="adr-0003"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar frontend requires strong typing for API responses, component props, and business logic to ensure maintainability and catch errors early.

### Alternatives

- **JavaScript only**: Simple but no type safety
- **Loose TypeScript**: Some typing but allows many errors
- **Strict TypeScript**: Maximum type safety with comprehensive error checking

### Decision

Implement strict TypeScript configuration:

- Enable strict mode with all strict flags
- Use path mapping for clean imports (@/ paths)
- Define comprehensive interfaces for API responses
- Use generic types for reusable components
- Enable noImplicitAny and strictNullChecks

### Consequences

- **Pros**: Maximum type safety, better IDE support, catches errors at compile time, self-documenting code
- **Cons / risks**: Steeper learning curve, more verbose code, requires understanding of advanced TypeScript features
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

All files use proper TypeScript types. No 'any' types are used. API responses have proper interfaces. Components have typed props.

---

## ADR-0004 — Build Tool with Vite

<a id="adr-0004"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar frontend needs fast development builds and optimized production builds. The build tool should work well with React, TypeScript, and modern development practices.

### Alternatives

- **Create React App**: Simple but slow and limited customization
- **Webpack with custom config**: Powerful but complex setup
- **Vite**: Fast, modern, and excellent developer experience

### Decision

Implement Vite as the build tool:

- Use Vite with React plugin for fast HMR
- TypeScript support out of the box
- Optimized production builds with code splitting
- Environment variable handling
- Plugin ecosystem for additional features

### Consequences

- **Pros**: Extremely fast development, modern tooling, great TypeScript support, excellent developer experience
- **Cons / risks**: Newer tool with smaller ecosystem, some plugins might not be available
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Development server starts quickly. Hot module replacement works correctly. Production builds are optimized. TypeScript compilation works without errors.

---

## ADR-0005 — Styling with Tailwind CSS

<a id="adr-0005"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar frontend needs consistent, maintainable styling that supports responsive design and can be easily customized for different merchants.

### Alternatives

- **CSS Modules**: Scoped styles but requires separate CSS files
- **Styled Components**: CSS-in-JS but runtime overhead
- **Tailwind CSS**: Utility-first with excellent developer experience

### Decision

Implement Tailwind CSS for styling:

- Use utility-first approach for rapid development
- Custom design system with Tailwind configuration
- Responsive design with mobile-first approach
- Dark mode support
- Component-based styling patterns

### Consequences

- **Pros**: Rapid development, consistent design, responsive by default, excellent developer experience
- **Cons / risks**: Learning curve for utility classes, potential for inconsistent design without discipline
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Components use Tailwind classes consistently. Responsive design works across devices. Dark mode is properly implemented. Design system is followed.

---

## ADR-0006 — Authentication with Supabase Auth

<a id="adr-0006"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar frontend needs secure authentication for merchants and staff. The system must integrate with the Supabase backend and provide a smooth user experience.

### Alternatives

- **Custom JWT implementation**: Full control but complex security considerations
- **OAuth with external providers**: Secure but adds complexity
- **Supabase Auth**: Integrated solution with excellent developer experience

### Decision

Implement Supabase Auth for authentication:

- Use Supabase Auth client for user management
- JWT tokens for API authentication
- React Context for auth state management
- Protected routes with authentication guards
- Automatic token refresh handling

### Consequences

- **Pros**: Integrated with backend, secure by default, excellent developer experience, built-in user management
- **Cons / risks**: Vendor lock-in, limited customization compared to custom solutions
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Authentication flow works correctly. Protected routes require valid authentication. Token refresh is handled automatically. User state is properly managed.

---

## ADR-0007 — State Management with React Query

<a id="adr-0007"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar frontend needs to manage server state efficiently, handle caching, and provide a smooth user experience with loading states and error handling.

### Alternatives

- **useState + useEffect**: Simple but requires manual cache management
- **Redux**: Powerful but complex for server state
- **React Query**: Purpose-built for server state with excellent caching

### Decision

Implement React Query for server state management:

- Use React Query for all API calls and server state
- Automatic caching and background refetching
- Optimistic updates for better UX
- Error handling and retry logic
- Loading states and data synchronization

### Consequences

- **Pros**: Excellent caching, automatic background updates, great developer experience, built-in loading states
- **Cons / risks**: Learning curve for query patterns, additional bundle size
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

API calls use React Query hooks. Caching works correctly. Background refetching is enabled. Error states are properly handled.

---

## ADR-0008 — WhatsApp Commerce Frontend Architecture

<a id="adr-0008"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar frontend is part of a WhatsApp commerce platform that enables merchants to manage their stores, products, and orders through web dashboards.

### Alternatives

- **Separate admin and merchant interfaces**: Clear separation but more development effort
- **Single interface with role-based views**: Unified but potentially complex
- **Modular interface with role-based access**: Flexible and maintainable

### Decision

Implement modular interface with role-based access:

- Single React application with role-based routing
- Merchant dashboard for store management
- Admin interface for platform management
- Shared components for common functionality
- Responsive design for mobile and desktop

### Consequences

- **Pros**: Unified codebase, shared components, easier maintenance, consistent user experience
- **Cons / risks**: More complex routing logic, need to handle different user types
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Role-based access works correctly. Different user types see appropriate interfaces. Shared components are properly reused. Responsive design works across devices.
