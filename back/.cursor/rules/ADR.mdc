---
description: Log of all the key backend architectural decisions.
alwaysApply: false
---

# Architecture Decision Log

<!--
ADR_AGENT_PROTOCOL v1.0

You (the agent) manage this file as the single source of truth for all ADRs.

INVARIANTS
- Keep this exact file structure and headings.
- All ADR entries use H2 headings: "## ADR-XXXX — <Title>" (4-digit zero-padded ID).
- Allowed Status values: Proposed | Accepted | Superseded
- Date format: YYYY-MM-DD
- New entries must be appended to the END of the file.
- The Index table between the INDEX markers must always reflect the latest state and be sorted by ID desc (newest on top).
- Each ADR MUST contain: Date, Status, Owner, Context, Decision, Consequences.
- Each ADR must include an explicit anchor `<a id="adr-XXXX"></a>` so links remain stable.

HOW TO ADD A NEW ADR
1) Read the whole file.
2) Compute next ID:
   - Scan for headings matching: ^## ADR-(\d{4}) — .+$
   - next_id = (max captured number) + 1, left-pad to 4 digits.
3) Create a new ADR section using the “New ADR Entry Template” below.
   - Place it AFTER the last ADR section in the file.
   - Add an `<a id="adr-XXXX"></a>` line immediately below the heading.
4) Update the Index (between the INDEX markers):
   - Insert/replace the row for this ADR keeping the table sorted by ID descending.
   - Title in the Index MUST link to the anchor: [<Title>](#adr-XXXX)
   - If this ADR supersedes another: set “Supersedes” in this row, and update that older ADR:
       a) Change its Status to “Superseded”
       b) Add “Superseded by: ADR-XXXX” in its Consequences block
       c) Update the older ADR’s Index row “Superseded by” column to ADR-XXXX
5) Validate before saving:
   - Exactly one heading exists for ADR-XXXX
   - All required fields are present and non-empty
   - Index contains a row for ADR-XXXX and remains properly sorted
6) Concurrency resolution:
   - If a merge conflict or duplicate ID is detected after reading: recompute next_id from the current file state, rename your heading, anchor, and Index row accordingly, and retry once.

COMMIT MESSAGE SUGGESTION
- "ADR-XXXX: <Short Title> — <Status>"

END ADR_AGENT_PROTOCOL
-->

## Index

<!-- BEGIN:ADR_INDEX -->

| ID   | Title                                                     | Date       | Status   | Supersedes | Superseded by |
| ---- | --------------------------------------------------------- | ---------- | -------- | ---------- | ------------- |
| 0008 | [FastAPI + Supabase Architecture for WhatsApp Commerce](#adr-0008) | 2025-01-27 | Accepted | —          | —             |
| 0007 | [Postgres Outbox Pattern for Reliable Job Processing](#adr-0007) | 2025-01-27 | Accepted | —          | —             |
| 0006 | [WhatsApp Integration Architecture](#adr-0006)             | 2025-01-27 | Accepted | —          | —             |
| 0005 | [Payment Gateway Integration Strategy](#adr-0005)          | 2025-01-27 | Accepted | —          | —             |
| 0004 | [Inventory Management with Atomic Reservations](#adr-0004) | 2025-01-27 | Accepted | —          | —             |
| 0003 | [Service-Oriented Architecture Pattern](#adr-0003)         | 2025-01-27 | Accepted | —          | —             |
| 0002 | [Database Design with Row Level Security](#adr-0002)       | 2025-01-27 | Accepted | —          | —             |
| 0001 | [Testing Strategy with pytest and Test Database](#adr-0001) | 2025-01-27 | Accepted | —          | —             |

<!-- END:ADR_INDEX -->

---

## ADR-0001 — Testing Strategy with pytest and Test Database

<a id="adr-0001"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar WhatsApp checkout platform requires a robust testing strategy that validates both API endpoints and database operations. Tests need to work with real database connections to ensure data integrity and proper SQLAlchemy model behavior.

### Alternatives

- **Mock all database operations**: Fast but doesn't test real database behavior or constraints
- **Use production database**: Real but dangerous and affects live data
- **Test database with pytest**: Real database behavior in isolated test environment

### Decision

Implement pytest-based testing strategy with dedicated test database:

- Use pytest for all testing with proper fixtures and parametrization
- Test database connection to Supabase for integration tests
- Unit tests for service logic without database dependencies
- Integration tests that validate complete API workflows
- Database transactions are rolled back after each test

### Consequences

- **Pros**: Tests real database behavior, catches SQLAlchemy issues, validates complete workflows, isolated test environment
- **Cons / risks**: Requires test database setup, slower than mocks, more complex CI/CD configuration
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

All tests use pytest fixtures. Integration tests connect to test database. Database operations are properly isolated and rolled back. Test coverage includes both unit and integration scenarios.

---

## ADR-0002 — Database Design with Row Level Security

<a id="adr-0002"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar platform handles sensitive merchant and customer data that requires strict tenant isolation. Multiple merchants must be able to use the same database without accessing each other's data, and the system needs to scale securely.

### Alternatives

- **Application-level filtering**: Filter data in application code, prone to security vulnerabilities
- **Separate databases per merchant**: Secure but expensive and complex to manage
- **Row Level Security (RLS) with Supabase**: Database-level security with tenant isolation

### Decision

Implement Row Level Security (RLS) policies in Supabase Postgres:

- Enable RLS on all tenant tables (merchants, products, orders, customers)
- Create policies that filter by `merchant_id` for tenant isolation
- Use JWT claims to determine merchant context in policies
- All database operations automatically respect RLS policies
- Policies are defined in migration files and version controlled

### Consequences

- **Pros**: Database-level security, automatic tenant isolation, prevents data leaks, scales efficiently
- **Cons / risks**: Requires understanding of RLS policies, more complex policy management
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

All tenant tables have RLS enabled. Policies are tested to ensure proper isolation. JWT authentication provides merchant context for policy evaluation.

---

## ADR-0003 — Service-Oriented Architecture Pattern

<a id="adr-0003"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar platform requires complex business logic that involves multiple database operations, external API integrations, and coordinated workflows. The system needs to be maintainable, testable, and follow clear separation of concerns.

### Alternatives

- **All logic in API endpoints**: Simple but leads to fat controllers and poor testability
- **Domain-driven design with aggregates**: Complex but overkill for MVP
- **Service-oriented architecture**: Clear separation between API, business logic, and data access

### Decision

Implement service-oriented architecture with clear layers:

- **API Layer**: FastAPI endpoints handle HTTP concerns (validation, authentication, responses)
- **Service Layer**: Business logic and orchestration (OrderService, PaymentService, etc.)
- **Integration Layer**: External API clients (WhatsApp, Paystack, Korapay, Meta Catalog)
- **Data Layer**: SQLAlchemy models and database operations
- Services are injected into API endpoints via dependency injection

### Consequences

- **Pros**: Clear separation of concerns, highly testable, reusable business logic, easy to maintain
- **Cons / risks**: More files and classes, requires understanding of dependency injection
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

API endpoints are thin and delegate to services. Business logic is in service classes. External integrations are in separate integration classes. Services are properly unit tested.

---

## ADR-0004 — Inventory Management with Atomic Reservations

<a id="adr-0004"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar platform needs to prevent overselling when multiple customers try to purchase the same product simultaneously. Inventory must be reserved during checkout and released if payment fails or times out.

### Alternatives

- **Optimistic locking**: Check stock at payment time, risk overselling
- **Pessimistic locking**: Lock entire product during checkout, poor concurrency
- **Atomic reservations with TTL**: Reserve stock atomically with expiration time

### Decision

Implement atomic inventory reservations with time-to-live (TTL):

- Reserve stock atomically in database transaction during order creation
- Create `inventory_reservations` table with 15-minute TTL
- Use `reserved_qty` field on products table for real-time availability
- Background worker releases expired reservations
- Stock is decremented only on successful payment

### Consequences

- **Pros**: Prevents overselling, handles concurrency safely, automatic cleanup of expired reservations
- **Cons / risks**: More complex database schema, requires background worker, potential for temporary stock unavailability
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Reservations are created atomically. Expired reservations are cleaned up by background worker. Stock is only decremented on payment success. Concurrency tests verify no overselling occurs.

---

## ADR-0005 — Payment Gateway Integration Strategy

<a id="adr-0005"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar platform needs to support multiple payment gateways (Paystack and Korapay) for Nigerian merchants. The system must handle payment processing, webhook verification, and provide a unified interface for different payment providers.

### Alternatives

- **Single payment gateway**: Simple but limits merchant options and creates vendor lock-in
- **Payment gateway abstraction**: Complex but provides flexibility and reduces vendor dependency
- **Multiple gateways with unified interface**: Balance between flexibility and complexity

### Decision

Implement multiple payment gateway support with unified interface:

- Create `PaymentIntegration` base class with common interface
- Implement `PaystackIntegration` and `KorapayIntegration` classes
- Use factory pattern to instantiate correct integration based on merchant preference
- All integrations support payment link generation and webhook verification
- Payment data is normalized into common `Payment` model

### Consequences

- **Pros**: Merchant choice, reduced vendor lock-in, easier to add new gateways, unified payment handling
- **Cons / risks**: More complex code, need to maintain multiple integrations, different API behaviors
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

All payment gateways implement common interface. Payment data is normalized. Webhook verification works for all supported gateways. Factory pattern correctly instantiates integrations.

---

## ADR-0006 — WhatsApp Integration Architecture

<a id="adr-0006"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar platform is built around WhatsApp as the primary customer interface. The system needs to handle WhatsApp Cloud API integration, message sending, webhook processing, and WhatsApp Flows for interactive experiences.

### Alternatives

- **WhatsApp Business API directly**: Complex setup and maintenance, requires Meta verification
- **Third-party WhatsApp service**: Simple but adds dependency and cost
- **WhatsApp Cloud API with custom integration**: Full control and cost-effective

### Decision

Implement direct WhatsApp Cloud API integration:

- Use WhatsApp Cloud API for sending messages and handling webhooks
- Implement WhatsApp Flows for interactive experiences (address collection, discount codes)
- Create `WhatsAppIntegration` class for all WhatsApp operations
- Handle webhook signature verification for security
- Support both product messages and interactive messages

### Consequences

- **Pros**: Full control over WhatsApp features, cost-effective, direct API access, supports all WhatsApp capabilities
- **Cons / risks**: Complex setup, requires Meta app verification, need to handle API rate limits
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

WhatsApp integration handles all message types. Webhook verification is implemented. Flows work correctly for interactive experiences. Rate limiting is properly handled.

---

## ADR-0007 — Postgres Outbox Pattern for Reliable Job Processing

<a id="adr-0007"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar platform requires reliable processing of background jobs like inventory updates, catalog synchronization, and payment follow-ups. These jobs must be processed exactly once and survive system failures.

### Alternatives

- **In-memory job queues**: Fast but jobs are lost on system restart
- **External message brokers**: Reliable but adds infrastructure complexity
- **Postgres outbox pattern**: Reliable job processing using existing database

### Decision

Implement Postgres outbox pattern for reliable job processing:

- Create `outbox_events` table to store job payloads
- Use APScheduler worker to process outbox events
- Jobs are created atomically with business transactions
- Failed jobs are retried with exponential backoff
- Dead letter queue (DLQ) for permanently failed jobs

### Consequences

- **Pros**: Reliable job processing, no additional infrastructure, atomic with business operations, built-in retry logic
- **Cons / risks**: Database load from job processing, requires careful worker management
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Jobs are created atomically with business operations. Worker processes outbox events reliably. Failed jobs are retried and eventually moved to DLQ. System can recover from worker failures.

---

## ADR-0008 — FastAPI + Supabase Architecture for WhatsApp Commerce

<a id="adr-0008"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar WhatsApp checkout platform requires a modern, scalable architecture that can handle real-time messaging, payment processing, and inventory management. The system needs to be cost-effective, maintainable, and support rapid development.

### Alternatives

- **Firebase Functions + Firestore**: Simple but limited scalability and vendor lock-in
- **Microservices with Kubernetes**: Scalable but complex for MVP
- **FastAPI + Supabase + Railway**: Modern, scalable, cost-effective monolith

### Decision

Implement FastAPI + Supabase + Railway architecture:

- **Backend**: FastAPI (Python) with SQLAlchemy ORM for type safety and performance
- **Database**: Supabase (Postgres) with Row Level Security for multi-tenancy
- **Authentication**: JWT-based authentication with Supabase Auth
- **Deployment**: Railway for simple, cost-effective hosting
- **Integrations**: Direct API integrations (WhatsApp, Paystack, Korapay, Meta Catalog)
- **Job Processing**: Postgres outbox pattern with APScheduler

### Consequences

- **Pros**: Modern tech stack, excellent developer experience, cost-effective, scalable, type-safe, real-time capabilities
- **Cons / risks**: Learning curve for new technologies, requires understanding of Postgres and RLS
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

All components use the specified tech stack. Database operations use SQLAlchemy. Authentication uses JWT. Deployments use Railway. All integrations follow the service-oriented architecture pattern.
