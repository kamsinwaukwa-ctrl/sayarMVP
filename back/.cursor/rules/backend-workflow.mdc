---
globs: back/**
alwaysApply: false
---

# Backend Development Workflow

## Architecture

This project uses an event-driven architecture with FastAPI and Supabase. All business logic is organized into services that handle different types of requests and events. The data is saved in Postgres (Supabase) and updated on the frontend through React Query invalidation and Supabase Realtime subscriptions.

## Testing

You must always start from tests. We primarily use integration tests that test the user flow from start to finish. For example, for testing order management flow, you would test: creating order -> reserving inventory -> processing payment -> updating stock -> etc. Inside each test case you must check the results in the Postgres database. Test is considered passed when all database records are as expected.

**Important**: We check real database records after running each FastAPI endpoint. The same with external services. Never create useless unit tests that just test properties of the class. Instead, test the actual functionality of the class.

Use `pytest` to run tests. Integration tests require a test database connection to Supabase.

# Development Principles

All code must be clearly readable and maintainable. It must read like a story. Everything should be self-explanatory. You should not need tons of comments to understand what it does. The key idea is to make sure I can understand what the code does in 5 seconds. If I can't, you should refactor the code. Below is a list of principles that you must follow to achieve this:

- 🪟 **No broken windows**: Keep code clean from the start. Don't leave anything for later.
- 🔄 **DRY**: Don't repeat yourself. If you are about to write the same code twice, stop, reconsider your approach and refactor.
- 🌐 **Leave it better than you found it**: Improve bad code as you encounter it. Your code should clearly communicate its purpose.
- 🔁 **Write code once**: Don't repeat yourself. Make code modular and extract components when needed. Prefer types over obvious comments.
- 🧪 **Test First**: Do not start integrating any front-end features until they have been fully tested on the back end.
- 👨‍💻 **SOLID**: Follow SOLID principles. Write single purpose short self-contained functions.

## Development Rules

Below are the rules that you must follow when developing backend functionality:

- All database operations must be performed through SQLAlchemy models and service classes. Never make direct SQL queries.
- All third party APIs/clients must be wrapped in integration classes located in `src/integrations/`.
- Never make calls to Supabase directly. Always use service classes and SQLAlchemy models.
- All database model types should always be updated in `src/models/` with proper Pydantic validation.
- If you are creating multiple records from an event (like creating products from CSV file) - create a Factory class with a method `.from_csv(csv_path)` - this method should return an array of model instances.
- Row Level Security (RLS) policies must **always** be up to date in migration files. Define them as soon as possible.
- All third party APIs must be wrapped in integration classes located in `src/integrations/`.
- All FastAPI request and response types must be in `src/models/` with Pydantic validation.
- API endpoints should follow RESTful conventions: `POST /api/v1/{resource}`, `GET /api/v1/{resource}/{id}`, etc.
- All complex functionality that involves multiple models, other integrations, or complex logic should be wrapped in a Service class, located in `src/services/`.
- Use the outbox pattern for reliable job processing. Enqueue jobs to `outbox_events` table for async processing.

## Workflow

When building new features, you must always start from creating new test files or modifying existing test files. Follow the workflow below:

0. Before starting, create a to-do list for yourself, following this exact process.
1. Navigate to the `tests` directory and find the most relevant test files that contain a similar user flow.
   - If you cannot find any relevant test files, ask clarification from the user.
   - If it's a new feature, create a new test file.
2. Incorporate new functionality into the test files. Make sure to check types from the `models` folder or add new types as necessary.
3. Build the new feature following our service architecture and development principles.
4. Run the affected tests and check the results in terminal.
5. Keep iterating until all tests are passing. Do not stop until all tests are passing.
6. Add any new API routes to the appropriate router in `src/api/`.
7. Document any key architecture decisions (if any) in the `back/.cursor/rules/ADR.mdc` file.
8. Ensure database migrations and RLS policies are updated to reflect the new functionality.

## Common Patterns

### Creating a FastAPI Endpoint

```python
@router.post("/api/v1/orders", response_model=OrderResponse)
async def create_order(
    request: CreateOrderRequest,
    merchant: Merchant = Depends(get_current_merchant)
):
    # Implementation
    return OrderResponse(id=order.id, data=order.dict())
```

### Creating a SQLAlchemy Model

```python
class Order(Base):
    __tablename__ = "orders"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    merchant_id = Column(UUID(as_uuid=True), nullable=False)
    customer_id = Column(UUID(as_uuid=True), nullable=True)
    total_kobo = Column(BigInteger, nullable=False)
    status = Column(String(50), default="pending")
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
```

### Creating a Service

```python
class OrderService:
    def __init__(self, db: Session):
        self.db = db

    def create_order(self, merchant_id: UUID, order_data: CreateOrderRequest) -> Order:
        # Orchestrate multiple models and integrations
        pass
```

### Creating an Integration

```python
class WhatsAppIntegration:
    def __init__(self, access_token: str):
        self.access_token = access_token
        self.base_url = "https://graph.facebook.com/v18.0"

    async def send_message(self, phone_number_id: str, to: str, message: dict):
        # WhatsApp API implementation
        pass
```

## Guardrails

- NEVER run any deploy commands.
