---
description: Architectural Decision Records
globs:
alwaysApply: false
---

# Architecture Decision Log

<!--
ADR_AGENT_PROTOCOL v1.0

You (the agent) manage this file as the single source of truth for all ADRs.

INVARIANTS
- Keep this exact file structure and headings.
- All ADR entries use H2 headings: "## ADR-XXXX — <Title>" (4-digit zero-padded ID).
- Allowed Status values: Proposed | Accepted | Superseded
- Date format: YYYY-MM-DD
- New entries must be appended to the END of the file.
- The Index table between the INDEX markers must always reflect the latest state and be sorted by ID desc (newest on top).
- Each ADR MUST contain: Date, Status, Owner, Context, Decision, Consequences.
- Each ADR must include an explicit anchor `<a id="adr-XXXX"></a>` so links remain stable.

HOW TO ADD A NEW ADR
1) Read the whole file.
2) Compute next ID:
   - Scan for headings matching: ^## ADR-(\d{4}) — .+$
   - next_id = (max captured number) + 1, left-pad to 4 digits.
3) Create a new ADR section using the “New ADR Entry Template” below.
   - Place it AFTER the last ADR section in the file.
   - Add an `<a id="adr-XXXX"></a>` line immediately below the heading.
4) Update the Index (between the INDEX markers):
   - Insert/replace the row for this ADR keeping the table sorted by ID descending.
   - Title in the Index MUST link to the anchor: [<Title>](#adr-XXXX)
   - If this ADR supersedes another: set “Supersedes” in this row, and update that older ADR:
       a) Change its Status to “Superseded”
       b) Add “Superseded by: ADR-XXXX” in its Consequences block
       c) Update the older ADR’s Index row “Superseded by” column to ADR-XXXX
5) Validate before saving:
   - Exactly one heading exists for ADR-XXXX
   - All required fields are present and non-empty
   - Index contains a row for ADR-XXXX and remains properly sorted
6) Concurrency resolution:
   - If a merge conflict or duplicate ID is detected after reading: recompute next_id from the current file state, rename your heading, anchor, and Index row accordingly, and retry once.

COMMIT MESSAGE SUGGESTION
- "ADR-XXXX: <Short Title> — <Status>"

END ADR_AGENT_PROTOCOL
-->

## Index

<!-- BEGIN:ADR_INDEX -->

| ID   | Title                                                        | Date       | Status   | Supersedes | Superseded by |
| ---- | ------------------------------------------------------------ | ---------- | -------- | ---------- | ------------- |
| 0009 | [Authentication: App-Managed JWT + Admin/Staff Roles](#adr-0009) | 2025-09-16 | Accepted | 0003       | —             |
| 0008 | [WhatsApp Commerce Platform Architecture](#adr-0008)         | 2025-01-27 | Accepted | —          | —             |
| 0007 | [Frontend Architecture with React + Vite](#adr-0007)         | 2025-01-27 | Accepted | —          | —             |
| 0006 | [Database Architecture with Supabase Postgres](#adr-0006)    | 2025-01-27 | Accepted | —          | —             |
| 0005 | [Backend Architecture with FastAPI](#adr-0005)               | 2025-01-27 | Accepted | —          | —             |
| 0004 | [Monorepo Structure for Full-Stack Development](#adr-0004)   | 2025-01-27 | Accepted | —          | —             |
| 0003 | [Authentication Strategy with JWT](#adr-0003)                | 2025-01-27 | Superseded | —          | 0009          |
| 0002 | [Deployment Strategy with Railway](#adr-0002)                | 2025-01-27 | Accepted | —          | —             |
| 0001 | [Testing Strategy with pytest and Test Database](#adr-0001)  | 2025-01-27 | Accepted | —          | —             |

<!-- END:ADR_INDEX -->

---

## New ADR Entry Template (copy for each new decision)

> Replace placeholders, keep section headers. Keep prose concise.

```

## ADR-XXXX — \<Short, specific title>

<a id="adr-XXXX"></a>
**Date**: YYYY-MM-DD
**Status**: Proposed | Accepted | Superseded
**Owner**: <Name>

### Context

<1–3 sentences: what changed or what forces drive this decision now>

### Alternatives

<Quick bullet list of alternatives considered, and why they were rejected.>

### Decision

\<Single clear decision in active voice; make it testable/verifiable>

### Consequences

* **Pros**: \<benefit 1>, \<benefit 2>
* **Cons / risks**: \<cost 1>, \<risk 1>
* **Supersedes**: ADR-NNNN (if any)
* **Superseded by**: ADR-MMMM (filled later if replaced)

### (Optional) Compliance / Verification

\<How we’ll check this is honored: tests, checks, fitness functions, runbooks>

```

---

## ADR-0001 — Testing Strategy with pytest and Test Database

<a id="adr-0001"></a>
**Date**: 2025-09-05  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar WhatsApp checkout platform requires a comprehensive testing strategy that validates both frontend and backend components. Tests need to work with real database connections to ensure data integrity and proper integration between React frontend and FastAPI backend.

### Alternatives

- **Mock all external dependencies**: Fast but doesn't test real integration behavior
- **Use production database**: Real but dangerous and affects live data
- **Test database with pytest**: Real database behavior in isolated test environment

### Decision

Implement pytest-based testing strategy with dedicated test database:

- Use pytest for all testing with proper fixtures and parametrization
- Test database connection to Supabase for integration tests
- Unit tests for service logic without database dependencies
- Integration tests that validate complete API workflows
- Frontend tests with React Testing Library and Jest
- Database transactions are rolled back after each test

### Consequences

- **Pros**: Tests real database behavior, catches integration issues, validates complete workflows, isolated test environment
- **Cons / risks**: Requires test database setup, slower than mocks, more complex CI/CD configuration
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

All tests use pytest fixtures. Integration tests connect to test database. Database operations are properly isolated and rolled back. Test coverage includes both unit and integration scenarios for frontend and backend.

---

## ADR-0002 — Deployment Strategy with Railway

<a id="adr-0002"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar platform needs a cost-effective, scalable deployment solution that can handle both frontend and backend components. The system needs to be easy to deploy, maintain, and scale as the business grows.

### Alternatives

- **AWS/GCP with Kubernetes**: Scalable but complex setup and high cost for MVP
- **Vercel for frontend + separate backend hosting**: Good for frontend but adds complexity
- **Railway for full-stack deployment**: Simple, cost-effective, and supports both frontend and backend

### Decision

Implement Railway deployment strategy:

- Deploy FastAPI backend to Railway with automatic HTTPS and custom domains
- Deploy React frontend to Railway with static site hosting
- Use Railway's built-in database integration with Supabase
- Environment variables managed through Railway dashboard
- Automatic deployments from GitHub with preview environments

### Consequences

- **Pros**: Simple deployment, cost-effective for MVP, automatic HTTPS, easy scaling, integrated database
- **Cons / risks**: Vendor lock-in, limited customization compared to cloud providers
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Both frontend and backend deploy successfully to Railway. Environment variables are properly configured. Database connections work in production. HTTPS is enabled and working.

---

## ADR-0003 — Authentication Strategy with JWT

<a id="adr-0003"></a>
**Date**: 2025-01-27  
**Status**: Superseded  
**Owner**: AI Agent

### Context

The Sayar platform needs secure authentication for merchants and staff members. The system must handle user sessions, role-based access control, and integrate with both frontend and backend components.

### Alternatives

- **Session-based authentication**: Simple but requires server-side session storage
- **OAuth with external providers**: Secure but adds complexity and dependency
- **JWT with Supabase Auth**: Stateless, secure, and integrates well with the tech stack

### Decision

Implement JWT-based authentication with Supabase Auth:

- Use Supabase Auth for user management and JWT token generation
- JWT tokens contain user ID, merchant ID, and role information
- Frontend stores JWT in secure HTTP-only cookies
- Backend validates JWT tokens on protected routes
- Row Level Security (RLS) policies use JWT claims for data access control

### Consequences

- **Pros**: Stateless authentication, secure token-based access, integrates with Supabase, supports role-based access
- **Cons / risks**: Token management complexity, need to handle token refresh, security considerations for token storage
- **Supersedes**: —
- **Superseded by**: ADR-0009

### Compliance / Verification

JWT tokens are properly generated and validated. RLS policies work with JWT claims. Frontend authentication state is properly managed. Protected routes require valid authentication.

---

## ADR-0004 — Monorepo Structure for Full-Stack Development

<a id="adr-0004"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar platform requires coordinated development between React frontend and FastAPI backend. The system needs to support independent development while maintaining shared configuration and documentation.

### Alternatives

- **Separate repositories**: Independent versioning but coordination overhead and duplicate configuration
- **Nested backend in frontend**: Simple structure but mixes concerns and complicates deployment
- **Side-by-side monorepo**: Clear separation with shared root configuration

### Decision

Implement side-by-side monorepo structure:

- `/front/` - React (Vite + TypeScript) frontend application with its own package.json
- `/back/` - FastAPI (Python) backend with its own requirements.txt and structure
- Root-level configuration files (README.md, .gitignore, etc.)
- Shared documentation and development guidelines
- Independent deployment pipelines for frontend and backend

### Consequences

- **Pros**: Clear separation of concerns, independent tooling, shared documentation, coordinated development
- **Cons / risks**: Slightly more complex initial setup, need to manage two different development environments
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Directory structure clearly separates frontend and backend. Both components can be developed independently. Shared configuration is properly managed. Documentation covers both components.

---

## ADR-0005 — Backend Architecture with FastAPI

<a id="adr-0005"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar platform requires a robust backend that can handle WhatsApp webhooks, payment processing, inventory management, and API requests. The system needs to be fast, type-safe, and easy to maintain.

### Alternatives

- **Django**: Full-featured but heavy for API-focused application
- **Flask**: Lightweight but requires more boilerplate for type safety
- **FastAPI**: Modern, fast, type-safe, and excellent for API development

### Decision

Implement FastAPI backend architecture:

- Use FastAPI with Python 3.11+ for type safety and performance
- SQLAlchemy ORM for database operations with proper type hints
- Pydantic models for request/response validation
- Service-oriented architecture with clear separation of concerns
- Automatic API documentation with OpenAPI/Swagger

### Consequences

- **Pros**: Excellent performance, automatic validation, type safety, great developer experience, built-in documentation
- **Cons / risks**: Learning curve for async/await patterns, requires understanding of modern Python features
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

All API endpoints use proper type hints. Pydantic models validate all requests and responses. Service classes handle business logic. API documentation is automatically generated and accessible.

---

## ADR-0006 — Database Architecture with Supabase Postgres

<a id="adr-0006"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar platform needs a reliable, scalable database that can handle multi-tenant data with proper security isolation. The system must support real-time updates and provide excellent developer experience.

### Alternatives

- **Self-hosted Postgres**: Full control but requires database administration
- **AWS RDS/Azure Database**: Managed but expensive and complex setup
- **Supabase Postgres**: Managed Postgres with built-in features and excellent DX

### Decision

Implement Supabase Postgres database architecture:

- Use Supabase as managed Postgres database with built-in features
- Row Level Security (RLS) for multi-tenant data isolation
- Real-time subscriptions for live updates
- Built-in authentication and authorization
- Automatic API generation with PostgREST

### Consequences

- **Pros**: Managed database, built-in security, real-time capabilities, excellent developer experience, cost-effective
- **Cons / risks**: Vendor lock-in, limited customization compared to self-hosted solutions
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Database schema is properly designed with RLS policies. Multi-tenant isolation works correctly. Real-time subscriptions function as expected. Database migrations are version controlled.

---

## ADR-0007 — Frontend Architecture with React + Vite

<a id="adr-0007"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar platform needs a modern, performant frontend for merchant dashboards and admin interfaces. The system must be fast, maintainable, and provide excellent user experience.

### Alternatives

- **Next.js**: Full-stack framework but adds complexity for SPA
- **Create React App**: Simple but slow build times and limited customization
- **React + Vite**: Fast, modern, and excellent developer experience

### Decision

Implement React + Vite frontend architecture:

- Use React 18 with TypeScript for type safety
- Vite for fast development and building
- Tailwind CSS for styling and responsive design
- React Query for server state management
- React Router for client-side routing

### Consequences

- **Pros**: Fast development, excellent performance, modern tooling, great developer experience, type safety
- **Cons / risks**: Learning curve for modern React patterns, requires understanding of hooks and context
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

Frontend builds successfully with Vite. TypeScript compilation works without errors. React Query manages server state properly. Tailwind CSS provides responsive design.

---

## ADR-0008 — WhatsApp Commerce Platform Architecture

<a id="adr-0008"></a>
**Date**: 2025-01-27  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The Sayar platform is a WhatsApp-first commerce solution that enables merchants to sell products directly through WhatsApp conversations. The system needs to handle messaging, payments, inventory, and provide merchant dashboards.

### Alternatives

- **Traditional e-commerce platform**: Standard web store but doesn't leverage WhatsApp's reach
- **WhatsApp Business API only**: Limited to basic messaging without commerce features
- **Integrated WhatsApp commerce platform**: Complete solution with messaging, payments, and inventory

### Decision

Implement integrated WhatsApp commerce platform:

- WhatsApp Cloud API for messaging and interactive experiences
- FastAPI backend for business logic and webhook handling
- Supabase Postgres for data storage with multi-tenant isolation
- React frontend for merchant dashboards and admin interfaces
- Payment gateway integrations (Paystack, Korapay) for Nigerian market
- Inventory management with atomic reservations

### Consequences

- **Pros**: Leverages WhatsApp's massive user base, complete commerce solution, scalable architecture, cost-effective
- **Cons / risks**: Complex integration requirements, dependency on WhatsApp policies, requires Meta verification
- **Supersedes**: —
- **Superseded by**: —

### Compliance / Verification

WhatsApp integration works correctly. Payment processing functions properly. Inventory management prevents overselling. Merchant dashboards provide necessary functionality. Multi-tenant isolation is secure.

---

## ADR-0009 — Authentication: App-Managed JWT + Admin/Staff Roles

<a id="adr-0009"></a>
**Date**: 2025-09-16  
**Status**: Accepted  
**Owner**: AI Agent

### Context

The implementation uses application-managed JWT authentication in FastAPI with Argon2id password hashing and explicit RBAC enforced via Postgres RLS. The merchant owner role has been migrated to admin, standardizing roles to admin and staff, where staff are read-only within their tenant.

### Alternatives

- Supabase Auth-managed JWTs — increases coupling and deviates from the current FastAPI auth stack
- Session-based authentication — requires server-side session storage, not aligned with stateless APIs

### Decision

Use app-managed JWT authentication and two roles:

- Admin: full CRUD within tenant
- Staff: read-only within tenant

Implementation specifics:

- Argon2id hashing for passwords; optional pepper
- JWT issued/verified by FastAPI (Authorization: Bearer <token>) with claims including merchant_id and role
- RLS claims bridged per request to Postgres session
- Owner role is deprecated and migrated to admin

### Consequences

* **Pros**: Full control over auth flow, consistent with FastAPI stack, clear RBAC semantics, strong password hashing
* **Cons / risks**: Responsibility for token lifecycle/rotation; additional maintenance vs. managed auth
* **Supersedes**: ADR-0003
* **Superseded by**: —

### (Optional) Compliance / Verification

Integration tests cover register/login/me. RLS policies validated for admin (writes allowed) and staff (writes denied). Token includes merchant_id and role; middleware applies claims to DB session.

